# Signet Protocol Logstash Pipeline Configuration
# Processes Signet Protocol logs and sends to Elasticsearch

input {
  # File input for Signet Protocol logs
  file {
    path => "/var/log/signet-protocol/*.log"
    start_position => "beginning"
    sincedb_path => "/dev/null"
    codec => "json"
    tags => ["signet-protocol"]
  }
  
  # Beats input for structured logs
  beats {
    port => 5044
    tags => ["beats", "signet-protocol"]
  }
  
  # HTTP input for direct log shipping
  http {
    port => 8080
    codec => "json"
    tags => ["http", "signet-protocol"]
  }
  
  # Syslog input for traditional logging
  syslog {
    port => 514
    tags => ["syslog", "signet-protocol"]
  }
}

filter {
  # Only process Signet Protocol logs
  if "signet-protocol" in [tags] {
    
    # Parse timestamp if it's a string
    if [timestamp] {
      date {
        match => [ "timestamp", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "yyyy-MM-dd'T'HH:mm:ssZ" ]
        target => "@timestamp"
      }
    }
    
    # Parse receipt timestamp
    if [ts] {
      date {
        match => [ "ts", "ISO8601", "yyyy-MM-dd'T'HH:mm:ss.SSSZ", "yyyy-MM-dd'T'HH:mm:ssZ" ]
        target => "receipt_timestamp"
      }
    }
    
    # Extract trace ID patterns
    if [trace_id] {
      grok {
        match => { "trace_id" => "(?<trace_prefix>[^-]+)-(?<trace_timestamp>\d+)-(?<trace_suffix>.*)" }
        tag_on_failure => ["_grokparsefailure_trace_id"]
      }
    }
    
    # Parse exchange events
    if [event_type] == "exchange_created" {
      mutate {
        add_field => { "event_category" => "exchange" }
        add_field => { "event_action" => "create" }
      }
      
      # Extract payload information
      if [payload_type] {
        grok {
          match => { "payload_type" => "(?<payload_vendor>[^.]+)\.(?<payload_category>[^.]+)\.(?<payload_name>[^.]+)\.(?<payload_version>.*)" }
          tag_on_failure => ["_grokparsefailure_payload_type"]
        }
      }
      
      if [target_type] {
        grok {
          match => { "target_type" => "(?<target_vendor>[^.]+)\.(?<target_category>[^.]+)\.(?<target_name>[^.]+)\.(?<target_version>.*)" }
          tag_on_failure => ["_grokparsefailure_target_type"]
        }
      }
    }
    
    # Parse receipt events
    if [receipt_hash] {
      mutate {
        add_field => { "event_category" => "receipt" }
        add_field => { "event_action" => "generate" }
      }
      
      # Extract CID information
      if [cid] {
        grok {
          match => { "cid" => "(?<cid_codec>[^a-z]+)(?<cid_hash>.*)" }
          tag_on_failure => ["_grokparsefailure_cid"]
        }
      }
    }
    
    # Parse billing events
    if [vex_usage] or [fu_usage] {
      mutate {
        add_field => { "event_category" => "billing" }
        add_field => { "event_action" => "usage_update" }
      }
      
      # Convert usage fields to numbers
      if [vex_usage] {
        mutate {
          convert => { "vex_usage" => "integer" }
        }
      }
      
      if [fu_usage] {
        mutate {
          convert => { "fu_usage" => "integer" }
        }
      }
      
      if [cost_usd] {
        mutate {
          convert => { "cost_usd" => "float" }
        }
      }
      
      # Calculate usage percentages if limits are available
      if [vex_limit] and [vex_usage] {
        ruby {
          code => "
            vex_usage = event.get('vex_usage').to_f
            vex_limit = event.get('vex_limit').to_f
            if vex_limit > 0
              event.set('vex_usage_pct', (vex_usage / vex_limit * 100).round(2))
            end
          "
        }
      }
      
      if [fu_limit] and [fu_usage] {
        ruby {
          code => "
            fu_usage = event.get('fu_usage').to_f
            fu_limit = event.get('fu_limit').to_f
            if fu_limit > 0
              event.set('fu_usage_pct', (fu_usage / fu_limit * 100).round(2))
            end
          "
        }
      }
    }
    
    # Parse policy events
    if [policy_allowed] {
      mutate {
        add_field => { "event_category" => "policy" }
        add_field => { "event_action" => "evaluate" }
      }
      
      # Convert policy_allowed to boolean
      if [policy_allowed] == "true" {
        mutate {
          replace => { "policy_allowed" => true }
        }
      } else {
        mutate {
          replace => { "policy_allowed" => false }
        }
      }
    }
    
    # Parse error events
    if [success] == "false" or [error_message] {
      mutate {
        add_field => { "event_category" => "error" }
        add_field => { "log_level" => "ERROR" }
      }
      
      # Extract error patterns
      if [error_message] {
        grok {
          match => { "error_message" => "(?<error_type>[A-Z_]+):\s*(?<error_details>.*)" }
          tag_on_failure => ["_grokparsefailure_error"]
        }
      }
    } else if [success] == "true" {
      mutate {
        add_field => { "log_level" => "INFO" }
      }
    }
    
    # Parse latency information
    if [latency_ms] {
      mutate {
        convert => { "latency_ms" => "float" }
      }
      
      # Categorize latency
      if [latency_ms] {
        ruby {
          code => "
            latency = event.get('latency_ms').to_f
            if latency < 100
              event.set('latency_category', 'fast')
            elsif latency < 500
              event.set('latency_category', 'normal')
            elsif latency < 2000
              event.set('latency_category', 'slow')
            else
              event.set('latency_category', 'very_slow')
            end
          "
        }
      }
    }
    
    # Parse hop information for receipt chains
    if [hop] {
      mutate {
        convert => { "hop" => "integer" }
      }
      
      # Categorize chain position
      if [hop] == 1 {
        mutate {
          add_field => { "chain_position" => "first" }
        }
      } else {
        mutate {
          add_field => { "chain_position" => "continuation" }
        }
      }
    }
    
    # Add geographic information based on tenant
    if [tenant] {
      translate {
        field => "tenant"
        destination => "tenant_region"
        dictionary_path => "/etc/logstash/conf.d/tenant_regions.yml"
        fallback => "unknown"
      }
      
      translate {
        field => "tenant"
        destination => "tenant_tier"
        dictionary_path => "/etc/logstash/conf.d/tenant_tiers.yml"
        fallback => "standard"
      }
    }
    
    # Add service metadata
    mutate {
      add_field => { "service_name" => "signet-protocol" }
      add_field => { "service_version" => "%{[@metadata][version]}" }
      add_field => { "environment" => "%{[@metadata][environment]}" }
    }
    
    # Clean up temporary fields
    mutate {
      remove_field => [ "message", "host", "path", "@version" ]
    }
    
    # Add fingerprint for deduplication
    fingerprint {
      source => ["trace_id", "hop", "receipt_hash", "timestamp"]
      target => "[@metadata][fingerprint]"
      method => "SHA256"
    }
  }
}

output {
  # Send to Elasticsearch
  if "signet-protocol" in [tags] {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "signet-protocol-%{+YYYY.MM.dd}"
      document_id => "%{[@metadata][fingerprint]}"
      template_name => "signet-protocol"
      template => "/etc/logstash/templates/signet-protocol-template.json"
      template_overwrite => true
      
      # Routing based on event category
      routing => "%{event_category}"
      
      # Custom mapping for different event types
      if [event_category] == "receipt" {
        index => "signet-receipts-%{+YYYY.MM.dd}"
      } else if [event_category] == "billing" {
        index => "signet-billing-%{+YYYY.MM.dd}"
      } else if [event_category] == "error" {
        index => "signet-errors-%{+YYYY.MM.dd}"
      }
    }
  }
  
  # Send critical errors to separate index
  if [log_level] == "ERROR" or [policy_allowed] == false {
    elasticsearch {
      hosts => ["${ELASTICSEARCH_HOSTS:elasticsearch:9200}"]
      index => "signet-alerts-%{+YYYY.MM.dd}"
      document_id => "%{[@metadata][fingerprint]}-alert"
    }
  }
  
  # Debug output (remove in production)
  if "${LOGSTASH_DEBUG:false}" == "true" {
    stdout {
      codec => rubydebug
    }
  }
  
  # Send to monitoring system
  if [event_category] == "billing" and [vex_usage_pct] and [vex_usage_pct] > 80 {
    http {
      url => "${ALERT_WEBHOOK_URL}"
      http_method => "post"
      format => "json"
      mapping => {
        "alert_type" => "quota_warning"
        "tenant" => "%{tenant}"
        "usage_pct" => "%{vex_usage_pct}"
        "timestamp" => "%{@timestamp}"
      }
    }
  }
}
